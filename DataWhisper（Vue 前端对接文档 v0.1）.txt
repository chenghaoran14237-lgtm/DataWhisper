下面这份文档就是给 Gemini（前端工程师）的“联调交接说明”。它包含：**我们后端现在有什么能力、前端需要的接口清单与示例、图表 artifacts 的数据结构、以及我认为前端必须具备的页面/状态/错误处理**。你把它整份丢给 Gemini，他就能开工，不需要看你后端代码。

---

# DataWhisper（Vue 前端对接文档 v0.1）

## 1. 项目当前状态（后端已完成的能力）

你可以把后端理解为：**Excel 上传 + 会话 + 多轮消息 + 摘要记忆 + 工具式数据分析 + 图表数据产出**。

已实现能力：

* 会话 Session：创建/查询；每个 session 可绑定当前 upload（`current_upload_id`）
* Excel 上传：校验 `.xlsx`、大小限制、落盘、DB 记录 `file_uploads`、生成 `profile`（行列数/列名/dtypes/缺失率/预览）
* Excel 缓存：内存 cache + cache miss 时从磁盘回填（服务重启后可继续聊）
* Chat：`/api/excel/chat` 支持多轮对话；消息落库（`messages` 表）
* Summary：按 token 阈值触发摘要压缩（避免上下文无限增长）
* Agent：自然语言 → 工具计划 → pandas 多步执行 → 生成回答；趋势类问题会生成 `chart_spec`
* Messages 历史接口（模块10）：可分页拉取消息，并附带图表 artifacts（前端可直接渲染）

前端要做的事很清晰：**上传 → 聊天 → 历史 → 图表渲染 → 刷新恢复**。

---

## 2. 通用约定

* Base URL：本地开发通常 `http://127.0.0.1:8000`
* API 前缀：`/api`
* ID 字段：`session_id`、`upload_id` 都是 UUID 字符串
* 时间：`created_at` 为后端生成的时间字符串（ISO 格式，前端按字符串展示或转 Date 皆可）
* 文案：前端界面统一中文

---

## 3. 接口清单（前端必用）

### 3.1 健康检查（可选）

**GET** `/api/health`
用途：开发时验证后端是否在线。

响应示例：

```json
{ "status": "ok" }
```

---

### 3.2 Excel 上传（核心入口）

**POST** `/api/excel/upload`
Content-Type：`multipart/form-data`

表单字段：

* `file`：必填，`.xlsx`
* `session_id`：可选（Form 字段）。不填则后端自动创建 session，并返回新的 `session_id`

响应：`ExcelUploadResponse`

```json
{
  "session_id": "uuid-session",
  "upload_id": "uuid-upload",
  "filename": "demo.xlsx",
  "profile": {
    "rows": 123,
    "cols": 10,
    "columns": ["month", "sales", "..."],
    "dtypes": {"sales": "int64"},
    "missing_rate": {"sales": 0.0},
    "preview": [{"month": "Jan", "sales": "10"}]
  }
}
```

失败场景（前端要提示用户）：

* 400：不是 `.xlsx` / 文件损坏 / 缺 filename
* 413：文件太大（超过 `MAX_UPLOAD_MB`）
* 404：传了 session_id 但 session 不存在

前端建议：

* 上传成功后立即保存：`session_id`、`upload_id`、`filename`、`profile`
* 把 `session_id/upload_id` 写入 localStorage（用于刷新恢复）

---

### 3.3 发起对话（核心）

**POST** `/api/excel/chat`
Content-Type：`application/json`

请求：`ExcelChatRequest`

```json
{
  "session_id": "uuid-session",
  "upload_id": "uuid-upload",
  "message": "看一下 sales 趋势"
}
```

响应：`ExcelChatResponse`

```json
{
  "reply": "（助手回复文本）",
  "session_id": "uuid-session",
  "upload_id": "uuid-upload",
  "artifacts": [
    {
      "kind": "chart",
      "spec": {
        "type": "line",
        "x": { "name": "month", "values": ["Jan", "Feb", "Mar"] },
        "series": [
          { "name": "sales", "values": [10, 20, 5] }
        ]
      }
    }
  ]
}
```

失败场景：

* 400：message 太长（>2000 chars）
* 404：upload_id 不属于该 session 或不存在
* 409：理论上已尽量避免（cache miss 会回填）；若出现说明 stored_path 缺失/文件被删

前端建议：

* UI 体验：用户发送后立即把 user 消息插入列表（optimistic UI）
* 收到响应后插入 assistant 消息；若有 artifacts，渲染图表卡片
* 发送成功后，可以选择再拉一次 messages 历史做“对齐”（或只依赖本地追加）

---

### 3.4 拉取会话消息历史（模块10，前端渲染主数据源）

**GET** `/api/sessions/{session_id}/messages`

Query 参数：

* `limit`：默认 50，最大建议 200
* `cursor`：可选（上一页最后一条 message.id），用于翻页加载更早消息
* `include_debug`：可选（true/false）。默认 false；生产 UI 建议 false（debug 太大）

响应：`MessagesPage`

```json
{
  "items": [
    {
      "id": "uuid-msg",
      "role": "user",
      "content": "sales 趋势",
      "created_at": "2025-12-03T15:00:00",
      "artifacts": [],
      "extra": null
    },
    {
      "id": "uuid-msg2",
      "role": "assistant",
      "content": "（回复文本）",
      "created_at": "2025-12-03T15:00:01",
      "artifacts": [
        { "kind": "chart", "spec": { "type": "line", "...": "..." } }
      ],
      "extra": null
    }
  ],
  "next_cursor": "uuid-msg-oldest",
  "has_more": true
}
```

前端建议：

* 聊天页进入时：先从 localStorage 取 `session_id`，调用该接口拉历史
* 上拉加载更早：传 `cursor=next_cursor`
* artifacts 渲染：直接读每条 message 的 `artifacts`

---

## 4. 图表 artifacts 规范（前端渲染规则）

目前主要是折线图（line）：

```ts
type ChartSpecLine = {
  type: "line";
  x: { name: string; values: string[] };
  series: { name: string; values: (number|null)[] }[];
}
type Artifact = { kind: "chart"; spec: ChartSpecLine } | ...;
```

渲染建议（ECharts 思路）：

* xAxis.data = spec.x.values
* series[]：每条线一个 series，data=values
* null 值让图表断线即可（ECharts 默认支持）

---

## 5. 前端必须具备的页面与状态（建议 Gemini 按这个实现）

### 页面/路由

1. `/` 上传页

* 选择文件 + 上传按钮
* 上传成功后跳转 `/chat`，并保存 session_id/upload_id/profile

2. `/chat` 聊天页

* 顶部显示：文件名、行列数、列名（可折叠显示 profile）
* 消息列表：user/assistant 气泡
* 图表卡片：从 message.artifacts 渲染
* 输入框：发送消息
* 刷新恢复：从 localStorage 自动加载 session + 拉历史

### 状态管理（强烈建议）

* Pinia store：`useSessionStore`

  * sessionId, uploadId, filename, profile
  * messages[]（从 GET messages 来）
  * hasMore, nextCursor
* Axios 统一封装：baseURL、timeout、错误拦截（给用户 toast）

### 必要的 UX（让它“像产品”）

* 上传进度条（可选但很加分）
* 发送/等待中的 loading 状态
* 错误提示：文件格式、超大、后端离线等
* “新会话”按钮：清空 localStorage，回到上传页

---

## 6. 我认为“必须要有”的东西（为了个人可用 + 简历可信度）

前端侧必须要有：

* ✅ 能完整跑通：上传 → chat → 历史 → 图表渲染 → 刷新恢复
* ✅ 结构化代码：axios 封装、Pinia store、组件拆分（MessageBubble、ChartCard、UploadPanel）
* ✅ 基本错误处理与空态（没上传文件、没 session、后端不可用）
* ✅ README 级演示：怎么启动前端、怎么配置 baseURL、演示截图/GIF（简历杀伤力核心）

后端侧（为前端联调“必须”但你可能还没加的）：

* ✅ CORS（允许前端域名访问；本地开发可放宽）
* ✅ 统一错误格式（可选，但有助于前端统一 toast）

可选但很加分：

* 增加“会话信息恢复”接口或复用现有 `GET /api/sessions/{id}`（显示 current_upload_id）
* 增加“上传 profile 获取”接口（刷新时可重新拿 profile）——你现在主要靠 localStorage + messages artifacts，其实也够用

---

## 7. 开发联调手册（给 Gemini 的工作流）

1. 启动后端：uvicorn（8000）
2. 前端配置 `VITE_API_BASE_URL=http://127.0.0.1:8000`
3. 上传 demo.xlsx，拿到 session_id/upload_id/profile
4. 进入 chat：先 GET messages，再 POST chat
5. 问一句包含“趋势”的问题（例如 `sales 趋势`），确保能返回 artifacts，并能画出折线图
6. 刷新页面：仍能看到历史记录与图表

验收标准（Definition of Done）：

* 上传页能成功上传并跳转聊天页
* 聊天页能发送消息并显示回复
* 趋势问题能出现折线图卡片
* 刷新后聊天历史能恢复
* 代码结构清晰，可读可维护（store/api/components 分层）

---

# 你要模拟“多人协作”的建议流程

你（PM/Owner）给 Gemini：

* 这份接口文档
* 2 个 demo Excel（一个有 month/sales；一个有 region/sales）
* 你希望的 UI 风格（简单中文、偏干净）
* 约定：前端遇到接口字段不确定，以此文档为准；需要新增接口由你来提需求，我来改后端

---


下面给你一套“真实团队协作味儿很浓”的交付：**Jira 风格任务拆分（含验收标准）+ Vue 项目结构建议 + 关键组件草图/交互流程 + 联调 checklist**。

---

# DataWhisper 前端接入 — 任务拆分（Jira 风格）

## Epic DW-FE-0：前端基础工程搭建

### DW-FE-0.1 初始化项目与基础依赖

**目标**：创建 Vue3 + Vite 项目，装好路由/状态/请求/图表库
**建议依赖**：

* vue-router、pinia
* axios
* echarts（或 chart.js；推荐 echarts）
* dayjs（可选：时间格式化）
* UI：Element Plus / Naive UI / 自写 Tailwind（任选一种，默认 Element Plus 更省事）

**验收**：

* `npm run dev` 正常启动
* 有基本路由：`/`、`/chat`

---

## Epic DW-FE-1：API 层与状态层（可复用、可测试）

### DW-FE-1.1 Axios 封装（baseURL / timeout / 错误拦截）

**实现**：

* `VITE_API_BASE_URL` 环境变量
* 超时 20s（可配置）
* 统一错误处理：将后端 `detail` 显示给用户（toast/message）

**验收**：

* baseURL 可从 `.env.development` 配置
* 断开后端时前端能提示“后端不可用/网络错误”

### DW-FE-1.2 API 模块（upload/chat/messages）

**实现接口**：

* `uploadExcel(file, sessionId?)`
* `chatExcel({session_id, upload_id, message})`
* `listMessages(session_id, {limit, cursor})`

**验收**：

* 调用成功能拿到文档中约定字段
* TS 类型定义齐全（至少关键字段）

### DW-FE-1.3 Pinia Store：SessionStore

**字段**：

* `sessionId, uploadId, filename, profile`
* `messages[]`
* `nextCursor, hasMore`
* methods：`restoreFromLocalStorage()`, `saveToLocalStorage()`, `clearSession()`

**验收**：

* 刷新页面后能恢复 sessionId/uploadId
* clearSession 后回到上传页

---

## Epic DW-FE-2：上传页（/）

### DW-FE-2.1 UploadPanel UI（选择文件 + 上传 + 进度）

**交互**：

* 只允许 `.xlsx`
* 上传中禁用按钮，展示 loading
* 上传成功后跳转 `/chat`

**验收**：

* 上传成功得到 `session_id/upload_id/profile`
* localStorage 写入成功
* 跳转后聊天页能看到文件信息

---

## Epic DW-FE-3：聊天页（/chat）

### DW-FE-3.1 Chat 页面框架（Header + MessageList + Composer）

**Header**：

* filename
* rows/cols
* columns（折叠展开）

**验收**：

* 从 store 读取显示
* profile 不存在时有空态提示“请先上传文件”

### DW-FE-3.2 MessageList + 气泡组件

**组件**：

* `<MessageBubble role content createdAt />`
* user 右侧、assistant 左侧（基础样式即可）

**验收**：

* 能渲染 messages 接口返回的数据
* 支持滚动到底部

### DW-FE-3.3 ChartCard：渲染 artifacts（line）

**组件**：

* `<ChartCard spec />` 使用 ECharts
* 输入：`spec.type === "line"` 时渲染折线图

**验收**：

* 提问 “sales 趋势” 能看到折线图卡片
* null 值不会导致崩溃

### DW-FE-3.4 发送消息（Composer）

**流程**：

* optimistic 插入 user message（本地）
* 调 chat API
* 插入 assistant 回复
* 若响应含 artifacts：assistant message 下渲染 chart card
* 然后可选：再 GET messages 同步一次（建议做，避免本地/后端不一致）

**验收**：

* 能发消息、能收到回复
* loading 状态与错误提示正确

### DW-FE-3.5 历史恢复 + 分页加载

**实现**：

* 页面 mount 时：GET `/messages?limit=50`
* 上拉加载：cursor=next_cursor

**验收**：

* 刷新仍可看到历史
* 能加载更早消息

---

## Epic DW-FE-4：产品化细节（简历加分）

### DW-FE-4.1 新会话按钮

* 清空 localStorage + store reset + 跳转 `/`

### DW-FE-4.2 基础空态/错误态

* 未上传文件进入 chat：提示并引导返回上传
* 后端 404/400/413 显示友好消息

### DW-FE-4.3 README（前端）

包含：

* 如何启动
* 如何配置 baseURL
* 演示步骤（上传 demo.xlsx → sales 趋势 → 图表出现）

---

# Vue 项目结构建议（Gemini 按这个建）

```
frontend/
  src/
    api/
      client.ts           # axios instance + interceptors
      excel.ts            # uploadExcel, chatExcel
      sessions.ts         # listMessages
      types.ts            # TS types (Session, UploadResponse, Message, Artifact, ChartSpec)
    stores/
      session.ts          # pinia store
    router/
      index.ts
    pages/
      UploadPage.vue
      ChatPage.vue
    components/
      UploadPanel.vue
      SessionHeader.vue
      MessageList.vue
      MessageBubble.vue
      ChartCard.vue
      ChatComposer.vue
    utils/
      storage.ts          # localStorage helpers
      format.ts           # optional: time formatting
    App.vue
    main.ts
  .env.development        # VITE_API_BASE_URL
```

---

# 关键交互流程（给 Gemini 的实现参考）

## Flow A：首次使用

1. UploadPage 选择 `.xlsx` → 点击上传
2. 调 `/api/excel/upload` → 得到 `session_id/upload_id/profile`
3. store.setSession(...) + localStorage 保存
4. router push `/chat`
5. ChatPage mounted → GET `/api/sessions/{id}/messages`（一般为空）
6. 用户发消息 → `/api/excel/chat` → 显示回复/图表

## Flow B：刷新恢复

1. ChatPage mounted
2. store.restoreFromLocalStorage()
3. 若 sessionId 存在 → GET messages → 渲染
4. 若不存在 → 引导回 UploadPage

---

# 联调 Checklist（你拿来验收 Gemini）

* [ ] baseURL 可配置，换端口不改代码
* [ ] 上传成功跳转 chat 且 header 显示 profile
* [ ] 发送一句“sales 趋势”能出现折线图
* [ ] 刷新页面历史仍在（messages 重新加载）
* [ ] “新会话”清空后能重新上传
* [ ] 错误提示（413/400/404/网络断开）用户能看懂

---

# 我对 Gemini 的“接口契约”补充

为了避免联调扯皮，约定：

* 前端渲染消息主要依赖 `GET /api/sessions/{id}/messages`
* `POST /api/excel/chat` 的 `artifacts` 仅用于“即时渲染提速”，最终以 messages 拉回为准
* 图表 spec 目前只保证 `type=line`，后续可扩展 `bar/pie/table` 等

---

